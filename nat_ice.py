# -*- coding: utf-8 -*-
# **********************************************************************
#
# Copyright (c) 2003-2018 ZeroC, Inc. All rights reserved.
#
# This copy of Ice is licensed to you under the terms described in the
# ICE_LICENSE file included in this distribution.
#
# **********************************************************************
#
# Ice version 3.7.1
#
# <auto-generated>
#
# Generated from file `nat.ice'
#
# Warning: do not edit this file.
#
# </auto-generated>
#

from sys import version_info as _version_info_
import Ice, IcePy

# Start of module CONE
_M_CONE = Ice.openModule('CONE')
__name__ = 'CONE'

_M_CONE._t_Peer = IcePy.defineValue('::CONE::Peer', Ice.Value, -1, (), False, True, None, ())

if 'PeerPrx' not in _M_CONE.__dict__:
    _M_CONE.PeerPrx = Ice.createTempClass()
    class PeerPrx(Ice.ObjectPrx):

        def ping(self, peerID, context=None):
            return _M_CONE.Peer._op_ping.invoke(self, ((peerID, ), context))

        def pingAsync(self, peerID, context=None):
            return _M_CONE.Peer._op_ping.invokeAsync(self, ((peerID, ), context))

        def begin_ping(self, peerID, _response=None, _ex=None, _sent=None, context=None):
            return _M_CONE.Peer._op_ping.begin(self, ((peerID, ), _response, _ex, _sent, context))

        def end_ping(self, _r):
            return _M_CONE.Peer._op_ping.end(self, _r)

        def swap(self, info, context=None):
            return _M_CONE.Peer._op_swap.invoke(self, ((info, ), context))

        def swapAsync(self, info, context=None):
            return _M_CONE.Peer._op_swap.invokeAsync(self, ((info, ), context))

        def begin_swap(self, info, _response=None, _ex=None, _sent=None, context=None):
            return _M_CONE.Peer._op_swap.begin(self, ((info, ), _response, _ex, _sent, context))

        def end_swap(self, _r):
            return _M_CONE.Peer._op_swap.end(self, _r)

        def connect(self, peerID, context=None):
            return _M_CONE.Peer._op_connect.invoke(self, ((peerID, ), context))

        def connectAsync(self, peerID, context=None):
            return _M_CONE.Peer._op_connect.invokeAsync(self, ((peerID, ), context))

        def begin_connect(self, peerID, _response=None, _ex=None, _sent=None, context=None):
            return _M_CONE.Peer._op_connect.begin(self, ((peerID, ), _response, _ex, _sent, context))

        def end_connect(self, _r):
            return _M_CONE.Peer._op_connect.end(self, _r)

        def register(self, info, context=None):
            return _M_CONE.Peer._op_register.invoke(self, ((info, ), context))

        def registerAsync(self, info, context=None):
            return _M_CONE.Peer._op_register.invokeAsync(self, ((info, ), context))

        def begin_register(self, info, _response=None, _ex=None, _sent=None, context=None):
            return _M_CONE.Peer._op_register.begin(self, ((info, ), _response, _ex, _sent, context))

        def end_register(self, _r):
            return _M_CONE.Peer._op_register.end(self, _r)

        def check(self, info, context=None):
            return _M_CONE.Peer._op_check.invoke(self, ((info, ), context))

        def checkAsync(self, info, context=None):
            return _M_CONE.Peer._op_check.invokeAsync(self, ((info, ), context))

        def begin_check(self, info, _response=None, _ex=None, _sent=None, context=None):
            return _M_CONE.Peer._op_check.begin(self, ((info, ), _response, _ex, _sent, context))

        def end_check(self, _r):
            return _M_CONE.Peer._op_check.end(self, _r)

        def pong(self, context=None):
            return _M_CONE.Peer._op_pong.invoke(self, ((), context))

        def pongAsync(self, context=None):
            return _M_CONE.Peer._op_pong.invokeAsync(self, ((), context))

        def begin_pong(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_CONE.Peer._op_pong.begin(self, ((), _response, _ex, _sent, context))

        def end_pong(self, _r):
            return _M_CONE.Peer._op_pong.end(self, _r)

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_CONE.PeerPrx.ice_checkedCast(proxy, '::CONE::Peer', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_CONE.PeerPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::CONE::Peer'
    _M_CONE._t_PeerPrx = IcePy.defineProxy('::CONE::Peer', PeerPrx)

    _M_CONE.PeerPrx = PeerPrx
    del PeerPrx

    _M_CONE.Peer = Ice.createTempClass()
    class Peer(Ice.Object):

        def ice_ids(self, current=None):
            return ('::CONE::Peer', '::Ice::Object')

        def ice_id(self, current=None):
            return '::CONE::Peer'

        @staticmethod
        def ice_staticId():
            return '::CONE::Peer'

        def ping(self, peerID, current=None):
            raise NotImplementedError("servant method 'ping' not implemented")

        def swap(self, info, current=None):
            raise NotImplementedError("servant method 'swap' not implemented")

        def connect(self, peerID, current=None):
            raise NotImplementedError("servant method 'connect' not implemented")

        def register(self, info, current=None):
            raise NotImplementedError("servant method 'register' not implemented")

        def check(self, info, current=None):
            raise NotImplementedError("servant method 'check' not implemented")

        def pong(self, current=None):
            raise NotImplementedError("servant method 'pong' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_CONE._t_PeerDisp)

        __repr__ = __str__

    _M_CONE._t_PeerDisp = IcePy.defineClass('::CONE::Peer', Peer, (), None, ())
    Peer._ice_type = _M_CONE._t_PeerDisp

    Peer._op_ping = IcePy.Operation('ping', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), IcePy._t_string, False, 0),), (), ((), IcePy._t_string, False, 0), ())
    Peer._op_swap = IcePy.Operation('swap', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), IcePy._t_string, False, 0),), (), ((), IcePy._t_string, False, 0), ())
    Peer._op_connect = IcePy.Operation('connect', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), IcePy._t_string, False, 0),), (), ((), IcePy._t_string, False, 0), ())
    Peer._op_register = IcePy.Operation('register', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), IcePy._t_string, False, 0),), (), ((), IcePy._t_string, False, 0), ())
    Peer._op_check = IcePy.Operation('check', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), IcePy._t_string, False, 0),), (), ((), IcePy._t_string, False, 0), ())
    Peer._op_pong = IcePy.Operation('pong', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), ((), IcePy._t_string, False, 0), ())

    _M_CONE.Peer = Peer
    del Peer

if 'nat_type' not in _M_CONE.__dict__:
    _M_CONE.nat_type = Ice.createTempClass()
    class nat_type(Ice.EnumBase):

        def __init__(self, _n, _v):
            Ice.EnumBase.__init__(self, _n, _v)

        def valueOf(self, _n):
            if _n in self._enumerators:
                return self._enumerators[_n]
            return None
        valueOf = classmethod(valueOf)

    nat_type.FULL_CONE = nat_type("FULL_CONE", 0)
    nat_type.RESTRICT_CONE = nat_type("RESTRICT_CONE", 1)
    nat_type.RESTRICT_PORT_CONE = nat_type("RESTRICT_PORT_CONE", 2)
    nat_type.SYMMETIC = nat_type("SYMMETIC", 3)
    nat_type._enumerators = { 0:nat_type.FULL_CONE, 1:nat_type.RESTRICT_CONE, 2:nat_type.RESTRICT_PORT_CONE, 3:nat_type.SYMMETIC }

    _M_CONE._t_nat_type = IcePy.defineEnum('::CONE::nat_type', nat_type, (), nat_type._enumerators)

    _M_CONE.nat_type = nat_type
    del nat_type

# End of module CONE
